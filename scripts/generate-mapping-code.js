#!/usr/bin/env node

/**
 * Mapping Code Generator
 *
 * Automatically generates database schema and field mapping code
 * from extracted PDF field list.
 *
 * Usage:
 *   node scripts/generate-mapping-code.js
 *
 * Input:
 *   - field-list.json (generated by extract-pdf-fields.js)
 *
 * Output:
 *   - database-schema.sql (Supabase table schema)
 *   - field-mapping.js (JavaScript mapping code)
 *   - type-definitions.ts (TypeScript type definitions)
 */

const fs = require('fs');
const path = require('path');

const logger = {
  info: (msg) => console.log(`\x1b[34mℹ\x1b[0m ${msg}`),
  success: (msg) => console.log(`\x1b[32m✓\x1b[0m ${msg}`),
  warn: (msg) => console.log(`\x1b[33m⚠\x1b[0m ${msg}`),
  error: (msg) => console.log(`\x1b[31m✗\x1b[0m ${msg}`),
  header: (msg) => console.log(`\n${'═'.repeat(70)}\n${msg}\n${'═'.repeat(70)}`),
};

// File paths
const INPUT_PATH = path.join(__dirname, '../field-list.json');
const OUTPUT_DIR = path.join(__dirname, '../output');
const SCHEMA_OUTPUT = path.join(OUTPUT_DIR, 'database-schema.sql');
const MAPPING_OUTPUT = path.join(OUTPUT_DIR, 'field-mapping.js');
const TYPES_OUTPUT = path.join(OUTPUT_DIR, 'type-definitions.ts');

/**
 * Infer database column type from PDF field type
 * @param {Object} field - Field data from PDF
 * @returns {string} PostgreSQL column type
 */
function inferDatabaseType(field) {
  if (field.type === 'PDFTextField') {
    if (field.multiline) {
      return 'TEXT'; // Large text areas
    }
    // Check if field name suggests specific type
    if (field.name.includes('date')) {
      return 'DATE';
    }
    if (field.name.includes('time')) {
      return 'TIME';
    }
    if (field.name.includes('email')) {
      return 'VARCHAR(255)';
    }
    if (field.name.includes('phone') || field.name.includes('tel')) {
      return 'VARCHAR(50)';
    }
    // Default text field
    return field.maxLength ? `VARCHAR(${field.maxLength})` : 'VARCHAR(255)';
  }
  if (field.type === 'PDFCheckBox') {
    return 'BOOLEAN';
  }
  if (field.type === 'PDFDropdown' || field.type === 'PDFRadioGroup') {
    return 'VARCHAR(100)';
  }
  return 'VARCHAR(255)'; // Default fallback
}

/**
 * Infer TypeScript type from PDF field type
 * @param {Object} field - Field data from PDF
 * @returns {string} TypeScript type
 */
function inferTypeScriptType(field) {
  if (field.type === 'PDFCheckBox') {
    return 'boolean';
  }
  if (field.name.includes('date')) {
    return 'string'; // ISO date string
  }
  return 'string';
}

/**
 * Generate SQL schema for database table
 * @param {Array} fields - Field data array
 * @returns {string} SQL CREATE TABLE statement
 */
function generateDatabaseSchema(fields) {
  const columns = fields.map(field => {
    const columnName = field.name;
    const columnType = inferDatabaseType(field);
    return `  ${columnName} ${columnType}`;
  });

  const sql = `-- Auto-generated database schema
-- Generated at: ${new Date().toISOString()}
-- Total fields: ${fields.length}

CREATE TABLE IF NOT EXISTS incident_report_pdf (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  create_user_id UUID REFERENCES auth.users(id) NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  -- PDF Form Fields (auto-generated)
${columns.join(',\n')}
);

-- Create index on user ID for fast lookups
CREATE INDEX IF NOT EXISTS idx_incident_report_pdf_user_id
  ON incident_report_pdf(create_user_id);

-- Add updated_at trigger
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_incident_report_pdf_updated_at
  BEFORE UPDATE ON incident_report_pdf
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Enable Row Level Security
ALTER TABLE incident_report_pdf ENABLE ROW LEVEL SECURITY;

-- Policy: Users can only access their own data
CREATE POLICY "Users can view own incident reports"
  ON incident_report_pdf
  FOR SELECT
  USING (auth.uid() = create_user_id);

CREATE POLICY "Users can insert own incident reports"
  ON incident_report_pdf
  FOR INSERT
  WITH CHECK (auth.uid() = create_user_id);

CREATE POLICY "Users can update own incident reports"
  ON incident_report_pdf
  FOR UPDATE
  USING (auth.uid() = create_user_id);
`;

  return sql;
}

/**
 * Generate JavaScript field mapping code
 * @param {Array} fields - Field data array
 * @returns {string} JavaScript mapping code
 */
function generateFieldMapping(fields) {
  const mappings = fields.map(field => {
    return `  setFieldText('${field.name}', data.${field.name});`;
  });

  const code = `/**
 * Auto-generated PDF field mapping
 * Generated at: ${new Date().toISOString()}
 * Total fields: ${fields.length}
 *
 * Usage:
 *   const formFiller = require('./field-mapping.js');
 *   await formFiller.fillPdfForm(pdfDoc, userData);
 */

const { PDFDocument } = require('pdf-lib');

/**
 * Fill PDF form with data from database
 * @param {PDFDocument} pdfDoc - Loaded PDF document
 * @param {Object} data - User data from database
 */
async function fillPdfForm(pdfDoc, data) {
  const form = pdfDoc.getForm();

  /**
   * Helper function to set text field safely
   * @param {string} fieldName - PDF field name
   * @param {any} value - Value to set
   */
  const setFieldText = (fieldName, value) => {
    try {
      const field = form.getTextField(fieldName);
      if (field && value !== null && value !== undefined) {
        field.setText(String(value));
      }
    } catch (error) {
      // Field might not exist or wrong type - that's okay
      console.warn(\`Field not found or error setting: \${fieldName}\`);
    }
  };

  /**
   * Helper function to set checkbox safely
   * @param {string} fieldName - PDF field name
   * @param {boolean} value - Value to set
   */
  const setFieldCheckbox = (fieldName, value) => {
    try {
      const field = form.getCheckBox(fieldName);
      if (field) {
        if (value) {
          field.check();
        } else {
          field.uncheck();
        }
      }
    } catch (error) {
      console.warn(\`Checkbox field not found: \${fieldName}\`);
    }
  };

  // Auto-generated field mappings
${mappings.join('\n')}

  return pdfDoc;
}

module.exports = { fillPdfForm };
`;

  return code;
}

/**
 * Generate TypeScript type definitions
 * @param {Array} fields - Field data array
 * @returns {string} TypeScript interface
 */
function generateTypeDefinitions(fields) {
  const properties = fields.map(field => {
    const tsType = inferTypeScriptType(field);
    return `  ${field.name}?: ${tsType};`;
  });

  const code = `/**
 * Auto-generated TypeScript types
 * Generated at: ${new Date().toISOString()}
 * Total fields: ${fields.length}
 */

export interface IncidentReportPdfData {
  // System fields
  id?: string;
  create_user_id?: string;
  created_at?: string;
  updated_at?: string;

  // PDF Form Fields (auto-generated)
${properties.join('\n')}
}
`;

  return code;
}

/**
 * Main execution
 */
async function main() {
  try {
    logger.header('🚀 MAPPING CODE GENERATOR');

    // Check if input file exists
    if (!fs.existsSync(INPUT_PATH)) {
      logger.error(`Field list not found: ${INPUT_PATH}`);
      console.log('\nRun this first: node scripts/extract-pdf-fields.js\n');
      process.exit(1);
    }

    // Load field data
    logger.info('Loading field list...');
    const fieldData = JSON.parse(fs.readFileSync(INPUT_PATH, 'utf-8'));
    const fields = fieldData.fields;
    logger.success(`Loaded ${fields.length} fields from ${fieldData.pdf_path}`);

    // Create output directory
    if (!fs.existsSync(OUTPUT_DIR)) {
      fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    }

    // Generate database schema
    logger.info('Generating database schema...');
    const schemaCode = generateDatabaseSchema(fields);
    fs.writeFileSync(SCHEMA_OUTPUT, schemaCode);
    logger.success(`Created: ${SCHEMA_OUTPUT}`);

    // Generate field mapping code
    logger.info('Generating field mapping code...');
    const mappingCode = generateFieldMapping(fields);
    fs.writeFileSync(MAPPING_OUTPUT, mappingCode);
    logger.success(`Created: ${MAPPING_OUTPUT}`);

    // Generate TypeScript types
    logger.info('Generating TypeScript types...');
    const typesCode = generateTypeDefinitions(fields);
    fs.writeFileSync(TYPES_OUTPUT, typesCode);
    logger.success(`Created: ${TYPES_OUTPUT}`);

    // Summary
    console.log('\n✅ Code generation complete!\n');
    console.log('Generated files:');
    console.log(`  📄 ${SCHEMA_OUTPUT}`);
    console.log(`  📄 ${MAPPING_OUTPUT}`);
    console.log(`  📄 ${TYPES_OUTPUT}`);
    console.log('\nNext steps:');
    console.log('1. Review generated files');
    console.log('2. Run database schema: psql < output/database-schema.sql');
    console.log('3. Integrate mapping code into your PDF service');
    console.log('4. Test with real data: node test-form-filling.js [user-uuid]\n');

  } catch (error) {
    logger.error(`Fatal error: ${error.message}`);
    console.error(error);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  main();
}

module.exports = { generateDatabaseSchema, generateFieldMapping, generateTypeDefinitions };
